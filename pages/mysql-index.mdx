## 인덱스

예를 들어 아래와 같은 데이터가 있습니다. 문자 `C` 를 찾으려면 끝까지 모두 읽어야 합니다.

| D    |
| ---- |
| Z    |
| B    |
| A    |
| K    |
| C    |

<br/>



이번에는 위의 데이터를 오름차순으로 정렬했습니다. 정렬된 표에서는 `C` 가 3번째에 있다는 사실이 확실하기에 더 빠르게 읽어올 수 있습니다.

| A    |
| ---- |
| B    |
| C    |
| D    |
| K    |
| Z    |

<br/>



### 인덱스를 사용하는 이유

무작위로 데이터의 위치를 O(N)으로 탐색하기 보다는 이렇게 정렬된 자료구조를 통해 데이터를 접근한다면 데이터를 탐색해야 하는 범위가 축소되기에 데이터의 접근 속도가 월등히 빨라지게 됩니다. **즉, 인덱스를 사용하는 이유는 '인덱스의 탐색 범위'를 줄여서 접근 속도를 최적화하기 위해서입니다.**<br/>



### 인덱스 자료구조의 원리

인덱스는 하나의 자료구조입니다. 데이터의 주소들을 특정 순서로 기억하고 있는 하나의 목차와 같은 역할을 합니다. 예를 들어 아래와 같은 테이블이 있습니다.<br/>

| 데이터 주소 | Ticker | 회사명    | 시가총액 |
| ----------- | ------ | --------- | -------- |
| 1           | MSFT   | Microsoft | 3.049 T  |
| 2           | NVDA   | Nvdia     | 1.97 T   |
| 3           | AAPL   | Apple     | 2.818 T  |

<br/>

 

만약 위의 데이터를 시가총액이 가장 낮은 회사를 찾는다거나 시가 총액이 가장 높은 회사를 찾는 다거나 하는 조회를 하려면 아래와 같은 자료구조를 미리 만들어두면 조회 성능상에 이점이 생깁니다.

| 시가총액 | 데이터 주소 |
| -------- | ----------- |
| 1.97 T   | 2           |
| 2.818 T  | 3           |
| 3.049 T  | 1           |

<br/>



만약 시가총액이 가장 낮은 회사를 찾아야 할 경우 가장 맨 처음에 나타난 `1.97T` 에 대한 데이터는 데이터 주소가 2 이고 데이터 주소 2 에 대한 원본 데이터를 확인해보면 `NVDA` 인 것을 확인 가능합니다.<br/>



만약 시가총액이 가장 높은 회사를 찾아야 한다면 가장 마지막에서 첫번째 데이터를 읽으면 되고, `3.049 T` 에 대해 데이터 주소가 1인데 데이터 주소 1에 대한 원본데이터를 확인해서 `MSFT` 라는 것을 확인 가능합니다.<br/>



## B+ Tree - 인덱스의 자료구조

### B+Tree 학습자료

- [https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

<br/>



### 여러가지 자료구조들과의 비교

List

- 정렬되지 않았을 때 : O(n)
- 정렬된 리스트에서는 : O(logN)
- 정렬되지 않은 리스트의 정렬 시간 복잡도는 : 평균 (Mlog(N))
- ArrayList와 같은 구조일 경우 삽입/삭제 시 비용이 높다.

<br/>

HashMap

- 단건 검색 속도 : O(1)
- 범위 탐색 : O(N)
- 전방 일치 탐색 불가 (e.g. like 'AB%')

<br/>

Tree

- 트리의 높이에 따라 시간복잡도가 결정된다.
- 트리의 높이를 최소화 하는 것이 중요
- 한쪽으로 노드가 치우치지 않도록 하는 균형잡힌 트리를 사용
- e.g. Red Black Tree, B+Tree, ...
- Red Black Tree 는 각 노드가 하나의 데이터 역할을 하고, B+Tree 의 각 노드는 리프노드의 주소 역할을 수행

<br/>



### B+Tree

`B+Tree` 는 데이터 자체는 하나의 링크드리스트로 구성되어 있고, 이 링크드 리스트는 트리의 리프로 구성되어 있습니다. 그리고 이 데이터의 주소로 구성된 트리를 이진탐색하면서 원하는 위치를 찾기에, 리프노드에 구성된 링크드 리스트에서 원하는 위치를 빠르게 찾아낼 수 있습니다.

![](./img/b-tree/1.png)

예를 들면 1\~17 까지의 데이터를 추가할 때 위와 같이 B+Tree 가 생성됩니다. 가장 마지막 리프노드에 `1~17` 데이터가 이어져있고, 각각의 트리는 데이터의 주소를 이진탐색할 수 있도록 구성되어 있음을 확인 가능합니다.<br/>

데이터가 insert 될 때 어떻게 동작하는지는 [https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html) 에서 확인 가능합니다.<br/>

<br/>



B+Tree 는 기본적으로 아래의 성격을 가집니다.

- 삽입/삭제 시 항상 균형을 유지
- 하나의 노드가 여러개의 자식 노드를 가지는 것 가능
- 리프노드에만 데이터가 존재하기에 연속적인 데이터에 접근 시에 장점을 가짐

<br/>



### mysql 의 B+Tree

mysql의 인덱스는 B+Tree 의 리프노드에 PK를 가지고 있습니다. 참고로 Oracle 에서는 B+Tree 의 리프노드에 데이터의 주소를 가지고 있습니다.<br/>

이렇게 PK를 B+Tree 의 리프노드에 가지고 있는 것은 PK를 클러스터드 인덱스로 가지고 있기에 용이한 구조임을 유추할 수 있습니다.<br/>

아래의 그림은 `Canada` 라는 인덱스 키를 검색할 때 B-Tree 의 주소를 어떻게 검색하는지 절차를 그림으로 그린 것입니다.

![](./img/b-tree/2.png)

<br/>

## 클러스터 인덱스

MySQL 의 PK 는 클러스터 인덱스로 이루어져 있습니다.<br/>

MySQL 의 PK가 아닌 일반 인덱스 역시 MySQL의 B+Tree 는 PK기반으로 구성하기에 일반 인덱스 역시 내부적으로는 PK를 가지며 클러스터 인덱스로 구성되어 있습니다.<br/>

<br/>



### 클러스터 인덱스, 장단점

클러스터 인덱스라는 것은 인덱스가 특정 범위를 두고 모여 있는 인덱스라는 것을 의미합니다. 클러스터 인덱스의 장점은 데이터의 지역성이 이뤄지기 때문에 데이터 조회시 조금 더 빠른 성능을 낼 수 있다는 점입니다. 반면, 데이터가 새로 들어올 때 재조정을 해야 할수도 있기 때문에 클러스터 인덱스가 리빌드 될 때의 오버헤드는 단점이 될 수 있습니다.

예를 들어 아래와 같은 데이터가 있다고 해보겠습니다.

| 클러스터 인덱스 키 | 데이터 주소 |
| ------------------ | ----------- |
| 100                | A           |
| 200                | B           |
| 300                | C           |
| 500                | D           |



이 상황에서 아래와 같이 새로운 데이터인 `400` 이 들어오는 경우에는 `500` 에 해당하는 클러스터 인덱스 키에 대한 데이터 주소는 재배치 됩니다.

| 클러스터 인덱스 키 | 데이터 주소 |
| ------------------ | ----------- |
| 100                | A           |
| 200                | B           |
| 300                | C           |
| 400 (새로들어옴)   | D           |
| 500                | E           |

이렇게 적은 데이터에서는 조금만 이동되었지만, 데이터가 많아지면 재배치할 데이터들이 많아지게 됩니다.<br/>



### 인덱스 역시 PK로 이뤄져 있으며 클러스터 인덱스로 구성

MySQL 의 PK가 아닌 일반 인덱스 역시 MySQL의 B+Tree 는 PK기반으로 구성하기에 일반 인덱스 역시 내부적으로는 PK를 가지며 클러스터 인덱스로 구성되어 있습니다.<br/>

<br/>



## 커버링 인덱스

커버링 인덱스는 데이터가 담긴 테이블을 직접 접근하지 않고도 인덱스로만 원하는 데이터에 접근할 수 있도록 구성한 인덱스를 의미합니다.<br/>

예를 들어 아래와 같은 데이터가 있다고 해보겠습니다.

| id(PK) | ticker | market_cap |
| ------ | ------ | ---------- |
| 1      | AAPL   | 2.818      |
| 2      | META   | 1.234      |
| 3      | MSFT   | 3.049      |
| 4      | NVDA   | 1.97       |

<br/>



그리고 시가총액인 `market_cap` 에 대한 인덱스가 아래와 같이 구성되어 있다고 해보겠습니다.

| market_cap | id(PK) |
| ---------- | ------ |
| 1.234      | 2      |
| 1.97       | 4      |
| 2.818      | 1      |
| 3.049      | 3      |

<br/>



이 때 아래와 같은 SQL은 테이블을 탐색하지 않고도 인덱스만으로도 원하는 데이터를 인출해올 수 있습니다.

```sql
SELECT market_cap
FROM stock_symbols
WHERE market_cap > 2;
```

<br/>



아래의 SQL 역시 원본 테이블을 탐색하지 않고도 인덱스만으로도 원하는 데이터를 인출해올 수 있습니다.

```sql
SELECT id, market_cap
FROM stock_symbols
WHERE market_cap > 2;
```

<br/>



그런데 이때 Ticker 데이터 역시 가져와야 하는 상황이 있습니다. 이런 경우에는 아래와 같은 SQL 을  사용한다면 커버링 인덱스를 거치게 되어서 데이터를 필요한 데이터만 접근해서 조회해오기에 효율적으로 조회할 수 있습니다.

```sql
SELECT A.id, A.ticker, A.market_cap
FROM stock_symbols A
INNER JOIN (
    SELECT id, market_cap
    FROM stock_symbols
    WHERE market_cap > 2
) B
 ON A.id = B.id
```

<br/>



커버링 인덱스를 사용하게 되면 order by, offset, limit 등을 사용하는 것으로 인한 불필요한 데이터 블록에 대한 접근을 커버링 인덱스를 이용해서 최소화할 수 있게 됩니다.<br/>

<br/>



## 인덱스 사용 시 주의해야 하는 점들

인덱스 사용 시 주의해야 할 점은 아래와 같습니다

- 인덱스 필드 가공은 피하는 것이 좋다
- 복합인덱스 사용시에는 복합된 컬럼을 모두 사용해야만 인덱스를 조회하게 된다
- 기본적으로 하나의 쿼리는 하나의 인덱스만 탄다

<br/>



SQL에 대해서 인덱스가 동작하지 않는 경우가 있을 수 있기 때문에, 성능이 중요한 쿼리일 경우 `explain` 을 통해서 확인하는 습관을 들이는 것을 추천합니다. <br/>

또한 무작정 인덱스를 사용한다고 해서 항상 성능이 향상된다는 고정관념 역시 탈피해야 하고 무분별한 인덱스 추가작업 인지 역시 충분히 고민을 해봐야 합니다. 인덱스를 사용하면 조회속도에 이점을 얻을 수는 있지만, 새로운 데이터 추가 시에 데이터베이스 내부적으로는 커버링 인덱스, B+Tree 의 데이터 위치들을 재정렬하는 등의 작업들이 일어납니다. 너무 과도한 인덱스 사용보다는 꼭 필요한 필드를 인덱스로 선택해서 사용하는 것을 권장합니다.<br/>

흔히 인덱스를 사용하는 것에 대해 `쓰기를 희생하고 조회를 얻는 것` 이라는 이야기를 합니다. 이 말을 떠올려서 꼭 필요한 곳에 인덱스를 사용하도록 고민을 해봐야 할 것 같습니다.<br/>

<br/>



### 인덱스 필드 가공은 피하는 것이 좋다

인덱스 필드를 가공하면 인덱스를 타지 못하게 됩니다.

예를 들어 아래의 테이블이 있다고 하겠습니다. `market_cap` 필드는 `biginteger` 타입으로 선언되어 있습니다.

| id(PK) | ticker | market_cap (indexed) |
| ------ | ------ | -------------------- |
| 1      | AAPL   | 2.818                |
| 2      | META   | 1.234                |
| 3      | MSFT   | 3.049                |
| 4      | NVDA   | 1.97                 |

<br/>



그리고 아래의 쿼리는 인덱스를 타지 못합니다. 자료형이 다르기 때문입니다. 이렇게 자료형이 다른 경우 옵티마이저는 내부적으로  to string 처리를 하게 되어서 인덱스를 통한 검색이 이뤄지지 않습니다.

```sql
SELECT * 
FROM stock_symbols
WHERE market_cap = '2.818'
```

<br/>



아래의 쿼리 역시 인덱스를 타지 못합니다. 인덱스 필드를 가공하고 있기 때문입니다.

```sql
SELECT * 
FROM stock_symbols
WHERE market_cap*100 = 2.818
```

<br/>



### 복합인덱스 사용시에는 복합된 컬럼을 모두 사용해야만 인덱스를 조회하게 된다

예를 들어 아래와 같은 테이블이 있다고 해보겠습니다. 복합 인덱스로 ticker, marekt\_cap 기반의 복합인덱스를 구성했습니다.

| id(PK) | ticker(indexed a1) | market_cap (indexed a2) | ceo             |
| ------ | ------------------ | ----------------------- | --------------- |
| 1      | AAPL               | 2.818                   | Tim Cook        |
| 2      | META               | 1.234                   | Mark Zuckerberg |
| 3      | MSFT               | 3.049                   | Satya Nadella   |
| 4      | NVDA               | 1.97                    | Jen-Hsun Huang  |

<br/>



이 경우 인덱스는 아래와 같이 구성됩니다.

| id(PK) | ticker(indexed a1) | market_cap (indexed a2) |
| ------ | ------------------ | ----------------------- |
| 1      | AAPL               | 2.818                   |
| 2      | META               | 1.234                   |
| 3      | MSFT               | 3.049                   |
| 4      | NVDA               | 1.97                    |

<br/>



복합인덱스 조합은 `{ ticker, market_cap }` 조합에 대해서 `ticker` 에 대해 먼저 정렬된 행에 대해서 `market_cap` 에 대해 정렬한 결과를 인덱스로 가지고 있는데, 만약 아래의 쿼리를 수행한다면 아래의 쿼리는 인덱스를 거치지 못하게 됩니다.

```sql
SELECT id, ticker, market_cap
FROM stock_symbols
WHERE market_cap > 1;
```

<br/>



왜냐하면 `market_cap` 은 복합 키 내에 보조적인 역할을 할 뿐이기에 `market_cap > 1` 처럼 `market_cap` 필드 하나에 대해서만 위치를 조회하는 것은 전혀 인덱스를 거치지 못합니다.

<br/>



### 기본적으로 하나의 쿼리는 하나의 인덱스만 탄다

하나의 쿼리는 하나의 인덱스만 탑니다. 여러 인덱스 테이블을 동시에 탐색하는 것은 기본적으로는 불가능하며, `index merge hint` 를 사용한다면 가능하기는 합니다. 따라서 `where` , `order by` , `group by` 를 사용하는 쿼리에서는 인덱스를 잘 고려해야 합니다.<br/>

