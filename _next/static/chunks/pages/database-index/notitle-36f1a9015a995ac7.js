(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[597],{1809:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/database-index/notitle",function(){return t(6525)}])},6525:function(e,n,t){"use strict";t.r(n),t.d(n,{__toc:function(){return o}});var i=t(5893),a=t(2673),d=t(373),r=t(8426);t(9128);var s=t(2643);let o=[{depth:2,value:"메모리 쓰기시 장애를 보완 - WAL",id:"메모리-쓰기시-장애를-보완---wal"},{depth:2,value:"저장장치 별 Latency",id:"저장장치-별-latency"},{depth:2,value:"인덱스",id:"인덱스"},{depth:2,value:"B+ Tree",id:"b-tree"}];function _createMdxContent(e){let n=Object.assign({h2:"h2",p:"p",strong:"strong",code:"code",ul:"ul",li:"li",a:"a"},(0,s.a)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h2,{id:"메모리-쓰기시-장애를-보완---wal",children:"메모리 쓰기시 장애를 보완 - WAL"}),"\n",(0,i.jsxs)(n.p,{children:["데이터베이스의 데이터는 최종적으로 디스크에 저장됩니다. 디스크는 메모리에 비해 성능이 많이 떨어집니다. 따라서 데이터베이스 성능에 있어서 핵심으로 두는 중점사항은 ",(0,i.jsx)(n.strong,{children:'"디스크로의 랜덤I/O 를 최소화하는 것"'})," 입니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["디스크 접근에는 순차 I/O 와 랜덤 I/O 가 있습니다. 순차 I/O는 가장 마지막에 읽었던 위치만 알고 있으면 되기에 쓰기 위치를 파악하는데에 있어서 많은 시간이 소요되지 않습니다. 랜덤 I/O 의 경우 원하는 데이터의 위치를 찾은 후 그 위치에 쓰기/수정 작업을 해야 하는데 이때 디스크에 접근하는 비용이 메모리에 접근하는 것에 비해 꽤 큽니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.p,{children:["이런 경우 ",(0,i.jsx)(n.strong,{children:"디스크에 접근하는 횟수를 줄이는 대신 메모리에 캐시 히트율을 높인다면 쓰기에 소요되는 비용이 줄어듭니다."})," 하지만 이 경우 메모리의 데이터가 유실될 수 있다는 점 역시 고려해야 합니다. 데이터베이스에 장애가 발생하면, 메모리에 있는 내용들은 디스크에 반영되지 않기에 디스크의 내용과 메모리의 내용이 일치하지 않는 상황이 발생할 수 있습니다. 이런 이유로 대부분의 데이터베이스는 이런 경우에 대비해 ",(0,i.jsx)(n.code,{children:"WAL(Write Ahead Log)"})," 기반으로 동작합니다.",(0,i.jsx)("br",{})]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://ko.wikipedia.org/wiki/%EB%A1%9C%EA%B7%B8_%EC%84%A0%ED%96%89_%EA%B8%B0%EC%9E%85",children:"WAL (Write Ahead Log)"})}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsxs)(n.p,{children:["데이터베이스는 쿼리 수행 전에 어떤 쿼리를 사용하는지 실행하려 했던 쿼리들의 기록을 ",(0,i.jsx)(n.strong,{children:"디스크에 순차기록"}),"을 해둡니다. 따라서 장애 등으로 인해 수행되지 않은 쿼리 들은 이 WAL 이라는 곳에서 읽어서 장애를 복구할 때 WAL에 쌓아둔 실행되지 않는 쿼리를 디스크에 반영합니다. 이렇게 해서 유실될 수 있는 쿼리 요청으로 인해 장애 직전 메모리에 남아있었던 결과와 디스크에 기록된 내용들이 달라질 수 있는 문제로 인한 데이터의 싱크가 깨지는 현상을 해결이 가능합니다. 이렇게 실행하려는 쿼리의 기록을 디스크에 순차 기록을 해두어 데이터의 싱크가 깨지는 현상을 방지하는 기술을 ",(0,i.jsx)(n.code,{children:"WAL(Write Ahead Log)"})," 라고 부릅니다. ",(0,i.jsx)("br",{})]}),"\n",(0,i.jsx)(n.h2,{id:"저장장치-별-latency",children:"저장장치 별 Latency"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://colin-scott.github.io/personal_website/research/interactive_latency.html",children:"Latency Numbers Every Programmer Should Know"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://gist.github.com/jboner/2841832",children:"gist.github.com/jboner/latency.txt"})}),"\n"]}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"인덱스",children:"인덱스"}),"\n",(0,i.jsx)("br",{}),"\n",(0,i.jsx)(n.h2,{id:"b-tree",children:"B+ Tree"}),"\n",(0,i.jsx)("br",{})]})}let c={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.a)(),e.components);return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/database-index/notitle.mdx",route:"/database-index/notitle",timestamp:1708831851e3,pageMap:[{kind:"MdxPage",name:"about",route:"/about"},{kind:"Folder",name:"database-index",route:"/database-index",children:[{kind:"MdxPage",name:"cluster-index",route:"/database-index/cluster-index"},{kind:"MdxPage",name:"covering-index",route:"/database-index/covering-index"},{kind:"MdxPage",name:"important-things-when-using-index",route:"/database-index/important-things-when-using-index"},{kind:"MdxPage",name:"notitle",route:"/database-index/notitle"},{kind:"MdxPage",name:"what-is-index",route:"/database-index/what-is-index"},{kind:"Meta",data:{notitle:"무제","what-is-index":"index 기본 원리, 자료구조","cluster-index":"클러스터 인덱스","covering-index":"커버링 인덱스","important-things-when-using-index":"인덱스의 주의해야 할 점들"}}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"primary-things",route:"/primary-things",children:[{kind:"MdxPage",name:"normalization-denormalization",route:"/primary-things/normalization-denormalization"},{kind:"Meta",data:{"normalization-denormalization":"정규화, 비정규화"}}]},{kind:"Folder",name:"transaction",route:"/transaction",children:[{kind:"MdxPage",name:"transaction-isolation-level",route:"/transaction/transaction-isolation-level"},{kind:"MdxPage",name:"what-is-acid",route:"/transaction/what-is-acid"},{kind:"MdxPage",name:"what-is-mvcc",route:"/transaction/what-is-mvcc"},{kind:"Meta",data:{"what-is-mvcc":"MVCC","what-is-acid":"트랜잭션의 기본 4원칙","transaction-isolation-level":"트랜잭션 격리수준"}}]},{kind:"Meta",data:{index:"Introduction","database-index":"인덱스",about:{title:"About",type:"page"},contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"Notitle",headings:o},pageNextRoute:"/database-index/notitle",nextraLayout:d.ZP,themeConfig:r.Z};n.default=(0,a.j)(c)},8426:function(e,n,t){"use strict";var i=t(5893);t(7294);let a={logo:(0,i.jsx)("span",{children:"My Project"}),project:{link:"https://github.com/chagchagchag/docs-mysql-essential"},docsRepositoryBase:"https://github.com/chagchagchag/docs-mysql-essential",footer:{text:"Nextra Docs Template"}};n.Z=a},5789:function(){}},function(e){e.O(0,[774,796,888,179],function(){return e(e.s=1809)}),_N_E=e.O()}]);